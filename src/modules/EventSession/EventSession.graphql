type EventSession {
  id: ID!
  model: EventModel
  title: String
  titlePrnt: String
  titleAny: String!
  intro: String
  introPrnt: String
  description: String
  descriptionPrnt: String
  mainMedia: Media
  medias: [Media!]!
  owner: User!
  start: DateTime
  end: DateTime
  tickets: [EventTicket!]!
  ticketCount: Int
  userStatus: UserStatus!
  seats: Int
  seatsPrnt: Int
  published: Boolean
  place: Place
  placePrnt: Place
  speaker: User
  speakerPrnt: User
  eventCats: [EventCat!]!
  eventCatsPrnt: [EventCat!]
}
type UserStatus {
  canTicket: Boolean!
  info: String!
  overlapping: EventSession
}

type Query {
  eventCatSessionList(eventCatId: ID!): [EventSession!]!
  eventModelSessionList(eventModelId: ID!): [EventSession!]!
  eventSessionList(filter: EventSessionFilter): [EventSession!]!
  eventSessionDetail(id: ID!): EventSession!
}
input EventSessionFilter {
  OR: [EventSessionFilter!]
  title_contains: String
  intro_contains: String
  description_contains: String
}


type Mutation {
  createEventSession(eventSessionInput: CreateEventSessionInput!): EventSession
  deleteEventSession(eventSessionId: ID!): Boolean
  updateEventSession(eventSessionInput: UpdateEventSessionInput!): EventSession
}
input CreateEventSessionInput {
  eventModelId: ID!
  title: String
  intro: String
  description: String
  seats: Int
  start: DateTime
  end: DateTime
  placeId: ID
  speakerId: ID
  eventCatIds: [ID!]
}
input UpdateEventSessionInput {
  id: ID!
  title: String
  intro: String
  description: String
  seats: Int
  start: DateTime
  end: DateTime
  placeId: ID
  speakerId: ID
  eventCatIds: [ID!]
}

type Subscription {
  EventSession(filter: EventSessionSubscriptionFilter): EventSessionSubscriptionPayload
}
input EventSessionSubscriptionFilter {
  mutation_in: [_ModelMutationType!]
}
type EventSessionSubscriptionPayload {
  mutation: _ModelMutationType!
  node: EventSession
}
