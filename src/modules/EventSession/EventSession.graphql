type EventSession {
  id: ID!
  model: EventModel
  title: String
  titleSuper: String
  intro: String
  introSuper: String
  description: String
  descriptionSuper: String
  mainMedia: Media
  medias: [Media!]!
  owner: User!
  speaker: User
  speakerSuper: User
  start: DateTime
  end: DateTime
  tickets: [EventTicket!]!
  ticketCount: Int
  userStatus: UserStatus!
  seats: Int
  seatsSuper: Int
  published: Boolean
  place: Place
  placeSuper: Place
  eventCats: [EventCat!]!
  eventCatsSuper: [EventCat!]
}
type UserStatus {
  canTicket: Boolean!
  info: String!
  overlapping: EventSession
}

type Query {
  eventCatSessionList(eventCatId: ID!): [EventSession!]!
  eventModelSessionList(eventModelId: ID!): [EventSession!]!
  eventSessionList(filter: EventSessionFilter): [EventSession!]!
  eventSessionDetail(id: ID!): EventSession!
}
input EventSessionFilter {
  OR: [EventSessionFilter!]
  title_contains: String
  intro_contains: String
  description_contains: String
}


type Mutation {
  createEventSession(eventSessionInput: CreateEventSessionInput!): EventSession
  deleteEventSession(eventSessionId: ID!): Boolean
  updateEventSession(eventSessionInput: UpdateEventSessionInput!): EventSession
}
input CreateEventSessionInput {
  eventModelId: ID!
  titleSuper: String
  introSuper: String
  descriptionSuper: String
  seatsSuper: Int
  start: DateTime
  end: DateTime
  placeSuperId: ID
  speakerSuperId: ID
  eventCatSuperIds: [ID!]
}
input UpdateEventSessionInput {
  id: ID!
  titleSuper: String
  introSuper: String
  descriptionSuper: String
  seatsSuper: Int
  start: DateTime
  end: DateTime
  placeSuperId: ID
  speakerSuperId: ID
  eventCatSuperIds: [ID!]
}

type Subscription {
  EventSession(filter: EventSessionSubscriptionFilter): EventSessionSubscriptionPayload
}
input EventSessionSubscriptionFilter {
  mutation_in: [_ModelMutationType!]
}
type EventSessionSubscriptionPayload {
  mutation: _ModelMutationType!
  node: EventSession
}
